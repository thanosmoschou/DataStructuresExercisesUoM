ΣΕ ΚΩΔΙΚΑ ΠΟΥ ΔΙΑΒΑΖΩ ΑΠΟ ΑΡΧΕΙΑ ΕΙΝΑΙ ΚΑΛΥΤΕΡΟ ΝΑ ΤΟ ΔΙΑΒΑΖΩ ΜΕ %s ΚΑΙ ΟΧΙ ΜΕ ΜΟΡΦΟΠΟΙΗΜΕΝΗ ΕΙΣΟΔΟ ΟΠΩΣ ΚΑΝΩ ΕΔΩ πχ %[^\r]%c%c ΓΙΑ ΝΑ ΔΙΑΒΑΣΩ ΠΡΙΝ ΤΟ \r ΚΑΙ ΜΕΤΑ ΝΑ ΔΙΑΒΑΣΩ ΩΣ ΧΑΡΑΚΤΗΡΕΣ ΤΑ \r ΚΑΙ \n. ΠΙΟ ΠΟΛΥ ΓΙΑ ΛΟΓΟΥΣ ΣΥΜΒΑΤΟΤΗΤΑΣ ΜΕ ΠΟΛΛΑ ΛΕΙΤΟΥΡΓΙΚΑ ΚΑΘΩΣ ΣΤΑ WINDOWS ΕΧΕΙ ΩΣ ΤΕΡΜΑΤΙΚΟ ΧΑΡΑΚΤΗΡΑ ΤΟ \r\n ΜΑΖΙ ΣΕ ΑΝΤΙΘΕΣΗ ΜΕ ΤΟ LINUX ΟΠΟΥ ΕΧΕΙ \n ΣΚΕΤΟ. ΑΝ ΘΕΣ ΝΑ ΔΙΑΒΑΣΕΙΣ ΜΕ ΚΑΠΟΙΟ ΣΥΓΚΕΚΡΙΜΕΝΟ ΜΟΤΙΒΟ ΓΙΑ ΛΟΓΟΥΣ ΑΣΦΑΛΕΙΑΣ ΘΑ ΤΟ ΚΑΝΕΙΣ ΜΕ fgets ΚΑΙ sscanf ΚΑΙ ΟΧΙ ΜΕ fscanf. ΕΝΩ ΣΓΗΝ ΕΚΔΟΣΗ UBUNTU 20.04 ΤΑ ΠΡΟΓΡΑΜΜΑΤΑ ΛΕΙΤΟΥΡΓΟΥΝ ΚΑΝΟΝΙΚΑ, ΣΕ ΔΙΑΝΟΜΕΣ WINDOWS ΕΝΔΕΧΕΤΑΙ ΝΑ ΠΑΡΟΥΣΙΑΣΤΟΥΝ ΣΦΑΛΜΑΤΑ ΜΕ ΤΗΝ ΑΝΑΓΝΩΣΗ ΟΠΟΤΕ ΠΡΕΠΕΙ ΝΑ ΓΙΝΕΙ ΤΡΟΠΟΠΟΙΗΣΗ ΤΩΝ ΑΡΧΕΙΩΝ Ή ΤΟΥ ΚΩΔΙΚΑ.  

Επισης:

Οταν διαβαζεις κατι με scanf το % αγνοει οτι whitespaces υπηρχαν πριν ( , \n κλπ)
Δηλ αν διαβασεις πχ 1 αριθμο, θα αγνοηθουν τα whitespaces που υπηρχαν. Αν τον διαβασεις και μετα πατησεις enter και μετα διαβασεις αλφαριθμητικο ΜΟΝΟ με %s(ή γενικά αν μετά το προηγούμενο διάβασμα, διαβάσεις οτιδηποτε αλλο πχ αριθμους με %d κλπ, ΕΚΤΟΣ απο αλφαριθμητικο μορφοποιημενης εισοδου δηλ αλφαριθμητικο που να πληροι καποιες προυποθεσεις πχ να εχει κενα αναμεσα) τοτε θα αγνοηθει το \n απο το 
προηγουμενο διαβασμα πχ του αριθμου.

Αν ομως εχεις διαβασει κατι και πατησεις enter αλλα μετα διαβασεις ενα αλφαριθμητικο με μορφοποιημενη μορφη πχ %[^character(ή \n)] τοτε:
1)Αν ο χαρακτηρας ειναι \n το \n θα παραμεινει στο ρευμα καθως θα λες να διαβαζει μεχρι να δει \n βλεπει αμεσως αρα φευγει και δε διαβαζει. 
2) Αν προκειται για 1 αλλο χαρακτηρα το \n θα περασει στο αλφαριθμητικο και το διαβασμα θα "κολλησει" μεχρι να δωσεις τον χαρακτηρα που θελει ωστε να σταματησει να διαβαζει.
